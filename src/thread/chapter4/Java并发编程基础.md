##Java并发编程基础
###线程介绍
####1：什么是线程
现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作
系统就会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫轻量级进程（Light
Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局
部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉
到这些线程在同时执行。
一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程
参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线
程。下面使用JMX来查看一个普通的Java程序包含哪些线程，如代码清单MultiThread所示

可以看到，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线
程的同时运行。
####2：为什么要使用多线程
省略
####3：线程优先级
现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线
程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程
分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需
要多或者少分配一些处理器资源的线程属性。

Java中使用一个整型成员变量priority来控制优先级，优先级范围从1-10，在线程创建的时候，
可以使用setPriority(int priority)方法来修改一个线程的优先级，默认的优先级都是5，优先级
高的线程分配到的时间片的数量多于优先级低的。

设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，
而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较
低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，
有些操作系统甚至会忽略对线程优先级的设定，示例如代码清单Priority所示。
####线程的状态
Java线程在运行的声明周期中共有六种状态，一个时间点，线程只能处于一个状态。

六个状态分别为：

- NEW  初始状态  线程已经被构建，但是还没有调用start()方法；
- RUNNABLE 运行状态，Java线程将操作系统中就绪和运行的两种状态统称为“运行中”；
- BLOCKED 阻塞状态，表示线程被阻塞于锁；
- WAITING 等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）
- TIME_WAITING 超时等待状态，在指定的时间后自动返回；
- TERMINATED 终止状态。

###线程间的通信
####等待/通知的经典范式
```java
synchronized(obj){
    while(条件不满足){
    obj.wait();
}
//条件满足
//处理逻辑
}

synchronized(obj){
    逻辑
    obj.notifyAll();
}
```
####管道输入输出流
管道输入/输出流与普通的文件输入/输出流或者网络输入/输出流不同的地方在于，它主要用于线程
之间的数据传输，而传输的媒介是内存。

管道输入/输出流主要有四种，PipedOutputStream,PipedInputStream,PipedReader,PipedWriter

对于Piped类型的流，必须先进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定
起来，那么对于该流的访问将会抛出异常。

#### Thread.join()方法
join()方法，含义是当前线程A等待thread线程终止之后才从thread.join()方法返回。

通俗点的意思就是，当前线程调用了join()方法，那么其他线程就得等该线程执行完成，再进行cpu的
资源竞争

#### ThreadLocal的使用
ThreadLocal，即线程变量，是一个以ThreadLocal为键，任意数据结构为值的存储结构，这个结构被
附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。

可以通过set(T)来设置一个值，然后在当前线程下用get()获取到原来设置的那个值。

在Profiler这个类的例子中，构建了一个常用的Profiler类，它具有begin()和end()两个
方法，而end()方法返回从begin()方法调用开始到end()方法被调用时的时间差，单位是毫秒。