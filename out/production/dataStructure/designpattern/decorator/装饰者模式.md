##装饰者模式
装饰者模式动态的将责任附加到对象上,若要扩展一个对象或者说类的功能,装饰者提供了比继承父类更弹性的替代方案.

装饰者模式的结构

主要分成两部分
1:产品(对象):定义一个公共的抽象超类,里面定义每种类型的产品共有的方法,比如星巴克,那就定义一个咖啡Beverage抽象类,
    然后继承他实现各种咖啡,比如黑咖啡,拿铁等等
2:装饰者:比如说加糖,不要糖,加热,加冰等等.定义一个抽象类,并且继承产品抽象超类,
    然后继承该装饰者抽象类生成个个装饰者
    
    
所以:
Beverage 产品(咖啡)抽象超类;
BlackBeverage(黑咖啡) 继承Beverage父类重新赋值description,实现cost()抽象方法
Latte(拿铁) 跟黑咖啡相同

CondimentDecorator(装饰者超类) 必须实现产品抽象超类 这样才会有同源 
Sugar(加糖) 继承CondimentDecorator装饰者超类  
Mocha(抹茶) 同加糖
